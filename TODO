DONE - add 'error'
	DONE - need strings first! :-)

- add some stdlib, not just builtins
	(define (newline) (display "\n"))

- add 'eval' and 'apply' builtins
	(eval '(+ 1 2)) => 3

DONE - add booleans? (lisp or scheme!)

DONE - write (failing) 'if' test which uses 'error' to check false branch not evaluated
	- go with 'truthy' for now
	- fix test by not evalauting if true/false branches until needed

DONE - import chibi tests
	- license and README

- start with basic chibi tests
	DONE - implement enough to run test00-fact-3.scm
	DONE - including stdout I/O
		- pass an io.Writer to eval
	- progressive evaiuation:
		DONE - have lexer take an io.Reader as input
			DONE - replaces string
			- pass in file+line+col start info to allow
			  select+eval
		- rename current parser.Parse method 'ParseAll'
		- add new method 'ParseOne' which returns after parsing one sexp
			- implement ParseAll as loop over Parse
		- add repl
	- add 'run file' to cmdline
	- add test runner to drive cmdline to load .scm and .res files from chibi
	- build simple static HTML report on test coverage

- variable bindings
	DONE - define
		- top level?
	DONE - syntactic sugar for functions
	- internal define?
		- what are the rules for scheme?

- handle parsing errors (e.g. #a as a bool)

- internal define

- add 'quote' special form
	- use same mechanism as 'if' to avoid default evaluation

- seperate tests to _test files
	- write repl
	- write cmdline tool
	- add some multi-line test cases (define funcs etc)
	- y combinator!
	- church numerals

- better numerics
	- golang types?
	- scheme numeric tower?

- reorg code
	- types + methods all in their own file

- pretty-print ast

- call into go code?
	- reserve '.' anywhere in identifier
	(.println "hello, world")
	(fmt.Printf "hello, world\n")
	- done by writing out golang src!?
		- instead of eval

- have decorate set up NodeError
	- e.g. decorateLet
	- reference the original node
	- which can in turn reference file, line and column

- add real test cases as xxx_test
	- explore go tap?

- test failed let decorate
	- check file/line/pos info

- add progn special form
	- implicit progn in let
		- so add one in decorate if needed

- work out what an applicable is so we can define addInt (maybe generic addNum?)

- add lambda to define our own applicables

- add some i/o applicable primitives


--------------------------------

DONE - add let special form


DONE - add int type so we can write simple test cases

DONE - add -ve integers and tests

DONE - work out where we should eval let binding bodies
	- needs to be eval-time so outer bindings work:
		(let ((+ *))
			(let ((x (+ 1 2)))
				x))

DONE - add '+' in default env
	- add NodeApplicable
	- no type info (or arity)
	- just helper funcs

DONE - lambda
	- has to carry env with it for eval
		- eval in env at the time
		- (let ((a 1))
			(let ((f (lambda (x) (+ a x))))
				(let ((a 2))
					(f 3))))

DONE - check application to redex
	- (+ (+ 1 2) (+ 2 3))
	- (let ((f (lambda (x) (+ 1 x))))
		(f (+ 1 2)))

DONE - progn

DONE - add implicit progn to let+lambda

