DONE - add int type so we can write simple test cases

DONE - add -ve integers and tests

DONE - work out where we should eval let binding bodies
	- needs to be eval-time so outer bindings work:
		(let ((+ *))
			(let ((x (+ 1 2)))
				x))

DONE - add '+' in default env
	- add NodeApplicable
	- no type info (or arity)
	- just helper funcs

- have decorate set up NodeError
	- e.g. decorateLet
	- reference the original node
	- which can in turn reference file, line and column

- add real test cases as xxx_test
	- explore go tap?

- test failed let decorate
	- check file/line/pos info

DONE - add let special form

- add progn special form
	- implicit progn in let
		- so add one in decorate if needed

- work out what an applicable is so we can define addInt (maybe generic addNum?)

- add lambda to define our own applicables

- add some i/o applicable primitives

